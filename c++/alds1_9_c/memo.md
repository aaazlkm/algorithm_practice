# alds1_9_c

- delete について思いを馳せる
  - child がいない場合は、iを削除
    - childが片方がいる場合は、入れ替え
    - さらに下の要素のことを考えないといけない
    - 一個ずつ上にずらさないといけないの普通にしんどいな
    - nodeでやらないと無理じゃね...??
    - でも回答だと、max heapでやってるわ....どうやるんだ？？
    - 一個ずつ移動するパターンは無理な気がする
      - 書いて考えてみたが、child -> parentに遷移する計算が、深さによって異なる
      - ここの計算ができる気がしないし、できたとしてもうまくない感じがする
    - 残りのものを再度insertするパターンは？
      - アリかもしれない、そっちの方が早そう毎回lognの計算がかかってしまうけど...
  - ~~childが両方がいる場合は、ちょっと考えないといけない~~ -> 
    - このパターンはない、一番右の要素に移動してるはずだから
- 左にchildがいた場合の処理について考える
  - 左にchildがいる場合は、左のchildをすべて再度入れ直す
    - 処理に時間がかかる
    - なんか間違える
  - 削除する時は、番兵を置いておいて、番兵がいる場合は、左に進むようにする
    - 番兵の下にさらに番兵がある場合に、探索しきれないな
    - この方法はきつそうな気がする
- 今のrenewの方法で動きとしてはできてる
  - #1-3まで正解したこととから
  - けど、メモリが足りない関係で#4の問題が間違っていそう
    - これは与えられた値にすごく偏りがある場合に、メモリが溢れ出ちゃうのだと思う
      - 例えば、右のchildにしか追加されないがひたらすら続くと簡単にメモリを溢れる
    - ということは、溢れた時に違う配列に飛ばせばいいのでは？
      - 2つ同じくらいの配列を確保することができない
    - じゃあ、余ってる部分をうまく使えるようにしないといけないのか、、
      - 溢れたら、treeを整理するのがいいのかもしれない
        - ひたすら右に追加されたら、その中間地点をrootとして持ってくれば、いい感じになる気がする
        - 結局優先度付きキューの取り出す順番が変わらなければ大丈夫なので、
          - insert の　i がmaxを超えてる時にその処理を入れるか
          - 中間地点をrootに持ってくるにはどうすればいいのだろうな？
            - 一回全部削除して、中間地点の場所からinsertし直せばいけそう
            - でもしんどいなこれ笑
              - 中間地点ってどうやれば取得できるんだ
              - 単純にiの半分って考えればいいのか
              - もっとシンプルな方法がある気がするので考えてみよう
- シンプルな方法を考える
  - 最大のキーを見つけるのはひたすら右に行けば見つかる
  - 問題は削除する時だよな
    - 削除する時にこの要素を一緒に削除することになる
    - これが非常にうまくない
  - てかこれ冷静に、nodeを使えばクリアできる気がするな
    - 配列でやってしまってるからうまくない気がする
    - 要は配列で確保してるせいで、無駄なメモリを食っていて、その結果うまくいっていない
    - これ配列でやらないといけないのかな... ？
- そもそもmaxヒープってなんだっけ？
  - maxヒープは、接点のキーがその親のキー以下であること
    - なるほど..?
    - だとしたら、この要素の削除問題はなくなるのか
      - いやなくなりはしないか
      - 結局途中の値を削除指定されたら終わりだもんな
      - いやいや、extract命令は最大キーを要求してるんだった
      - だから、途中の値が指定されることはない
        - じゃあ最大ヒープを構築していればいいのか
        - その中で最大の要素を探して返すだけでいける
        - maxヒープの中の最大値はどこにあるんだ？
          - 一番上だ
        - インサートしたあと毎回maxヒープかすればいいのか
- 結局maxヒープでも、削除する時のchildの管理が大変だな、どうするのがいいだろうか...